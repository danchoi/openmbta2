

select routes.route_id, max(routes.route_short_name) as route_short_name, count(route_id) from routes join trips using (route_id) group by routes.route_
id order by max(routes.route_short_name);



mbta=# select * from trips limit 10;
 route_id  |         service_id         | trip_id  | trip_headsign | direction_id | block_id | shape_id
-----------+----------------------------+----------+---------------+--------------+----------+----------
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942700 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942701 | Wonderland    |            1 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942702 | Wonderland    |            1 | B946_-18 |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942703 | Bowdoin       |            0 | B946_-7  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942704 | Wonderland    |            1 | B946_-7  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942705 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942706 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942707 | Wonderland    |            1 | B946_-6  |
 948_-1079 | RTL111-hmb11011-Weekday-01 | 13942708 | Bowdoin       |            0 | B9462-3  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942709 | Wonderland    |            1 | B9462-3  |


mbta=# select * from stops limit 10;
   stop_id   | stop_code |     stop_name     | stop_desc |  stop_lat   |   stop_lon   | zone_id | stop_url | location_type | parent_station
-------------+-----------+-------------------+-----------+-------------+--------------+---------+----------+---------------+----------------
 place-alfcl |           | Alewife Station   |           |   42.395428 |   -71.142483 |         |          |             1 |
 place-andrw |           | Andrew Station    |           |   42.330154 |   -71.057655 |         |          |             1 |
 place-aport |           | Airport Station   |           |   42.374262 |   -71.030395 |         |          |             1 |
 place-aqucl |           | Aquarium Station  |           |   42.359784 |   -71.051652 |         |          |             1 |
 place-armnl |           | Arlington Station |           |   42.351902 |   -71.070893 |         |          |             1 |
 place-asmnl |           | Ashmont Station   |           |   42.284652 |   -71.064489 |         |          |             1 |
 place-bbsta |           | Back Bay Station  |           |    42.34735 |   -71.075727 |         |          |             1 |
 place-bmmnl |           | Beachmont Station |           | 42.39754234 | -70.99231944 |         |          |             1 |
 place-bomnl |           | Bowdoin Station   |           |   42.361365 |   -71.062037 |         |          |             1 |
 place-brdwy |           | Broadway Station  |           |   42.342622 |   -71.056967 |         |          |             1 |


mbta=# select * from stop_times limit 10;
 trip_id  | arrival_time | departure_time | stop_id | stop_sequence | stop_headsign | pickup_type | drop_off_type
----------+--------------+----------------+---------+---------------+---------------+-------------+---------------
 14021448 | 06:40:00     | 06:40:00       | 1       |             2 |               |           0 |             0
 14021524 | 06:15:00     | 06:15:00       | 1       |             2 |               |           0 |             0
 14045401 | 06:00:00     | 06:00:00       | 1       |             2 |               |           0 |             0
 14045403 | 07:05:00     | 07:05:00       | 1       |             2 |               |           0 |             0
 14045405 | 08:05:00     | 08:05:00       | 1       |             2 |               |           0 |             0
 14045407 | 09:05:00     | 09:05:00       | 1       |             2 |               |           0 |             0
 14045408 | 10:25:00     | 10:25:00       | 1       |             2 |               |           0 |             0
 14045409 | 19:00:00     | 19:00:00       | 1       |             2 |               |           0 |             0
 14045410 | 19:18:00     | 19:18:00       | 1       |             2 |               |           0 |             0
 14045411 | 20:30:00     | 20:30:00       | 1       |             2 |               |           0 |             0


Problem with arrival times in Postgres


mbta=# select max(arrival_time) from stop_times;
max
---------
9:52:00
(1 row)

May need to switch over to MySQL and use Postgres just for the
geographical part for now?

Try loading the CSV data into MySQL


Mysql load data infile 
https://bugs.launchpad.net/ubuntu/+source/mysql-dfsg-5.0/+bug/244406


sed 's/"""/"/g' stops.txt > stops.fixed.txt


The CSV import is messed up for MySQL.

Trying Postgresql furhter


grep  '"[[:digit:]]\{1\}:' stop_times.txt > bad.stoptimes.txt
sed 's/\<[[:digit:]]\{1\}:/0&/g'


------------------------------------------------------------------------
Thu May 26 10:58:53 EDT 2011

Reorganized the calendar table. Now we can do this sort of query:

mbta=# select * from calendar where service_days[(select 2)] = true;
mbta=# select * from calendar where service_days[(select 7)] = true;
mbta=# select * from calendar where service_days[(select 6)] = true;

Much happier with that.

select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true;


OK I now have a much more useful calendar table.


         service_id          |  service_days   | start_date |  end_date
-----------------------------+-----------------+------------+------------
 BUSN11-hbf11011-Weekday-02  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbg11011-Weekday-03  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbg11016-Saturday-03 | {f,f,f,f,f,t,f} | 2011-03-05 | 2011-03-12
 BUSN11-hbg11017-Sunday-03   | {f,f,f,f,f,f,t} | 2011-03-06 | 2011-03-13
 BUSN11-hbl11011-Weekday-02  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbl11016-Saturday-02 | {f,f,f,f,f,t,f} | 2011-03-05 | 2011-03-12
 BUSN11-hbl11017-Sunday-02   | {f,f,f,f,f,f,t} | 2011-03-06 | 2011-03-13


select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();

This works great

select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();
         service_id         |  service_days   | start_date |  end_date
----------------------------+-----------------+------------+------------
 BUSN21-hbf21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbg21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbl21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbt21021-Weekday-02 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 BUSN21-htt21021-Weekday-02 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 BUSS21-hba21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbb21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbc21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbq21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbs21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 LRV211-hlb21021-Weekday-01 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 LRV211-hlm21021-Weekday-01 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 RTL211-hmb21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 RTL211-hmo21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 RTL211-hms21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 CR-Weekday                 | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
 Boat-FallWeekday           | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
 Logan-Weekday              | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
(18 rows)


create view current_services as select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();

fix calendar_date table to use date type


select service_id, service_type from (
  select service_id, 'normal' as service_type from calendar 
  where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now() 
  UNION
  select service_id, 'added' as service_type from calendar_dates 
  where exception_type = 'add' and date = now()
) services
EXCEPT 
  select service_id, 'removed' as service_type from calendar_dates 
  where exception_type = 'removed' and date = now();


CREATE FUNCTION active_services(date) RETURNS setof varchar AS $$
select service_id from (
  select service_id from calendar 
  where service_days[(select to_char($1, 'ID'))::int] = true and start_date <= $1 and end_date >= $1
  UNION
  select service_id from calendar_dates 
  where exception_type = 'add' and date = $1
) services
EXCEPT 
  select service_id from calendar_dates 
  where exception_type = 'remove' and date = $1;
$$ language sql;

select active_services(date('20110511'));
select active_services(date('20110530')) as service_id order by service_id;

------------------------------------------------------------------------

This is more explicit:


CREATE FUNCTION active_services2(date) RETURNS setof record AS $$
  select service_id, 'normal' as service_type from calendar 
  where service_days[(select to_char($1, 'ID'))::int] = true and start_date <= $1 and end_date >= $1
UNION
  select service_id, 'added' as service_type from calendar_dates 
  where exception_type = 'add' and date = $1
UNION 
  select service_id, 'remove' as service_type from calendar_dates 
  where exception_type = 'remove' and date = $1;
$$ language sql;


          active_services2
-------------------------------------
 (BUSN21-hbt21021-Weekday-02,normal)
 (RTL211-hmb21me7-Sunday-01,added)
 (Logan-Weekday,normal)
 (BUSN21-htt21021-Weekday-02,normal)
 (BUSS21-hba21011-Weekday-02,normal)
 (BUSN21-hbg21011-Weekday-02,normal)
 (LRV211-hlm21021-Weekday-01,remove)
 (BUSS21-hbc21011-Weekday-02,normal)
 (RTL211-hms21me7-Sunday-01,added)
 (BUSN21-hbl21011-Weekday-02,remove)
 (LRV211-hlb21021-Weekday-01,normal)
 (Boat-FallWeekday,normal)


select active_services2(date('20110530'));

select * from active_services2(date('20110530')) f(service_id text, service_type text);

Got it:

These two should be equivalent:

select active_services(date('20110530')) as service_id order by service_id;

select service_id, count(service_id) from active_services2(date('20110530')) f(service_id text, service_type text) group by service_id having count(service_id) < 2 order by service_id;

Use the first version, the second to check.


mbta=# select count(*) from trips where service_id in (select service_id current_services);
count
--------
121866
(1 row)

select count(*) from trips where service_id in ( select active_services(date('20110530')) as service_id order by service_id);



Now create a function that produces the trips records for a certain date.

CREATE FUNCTION active_trips(date) RETURNS SETOF trips AS $$
select * from trips where service_id in (select active_services($1) as service_id);
$$ LANGUAGE SQL;

This works:

select * from active_trips(date(now()));

Next we need a function that shows the active trips for a mode of transport


use nullif and coalesce:

select r.route_type, r.route_id, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, 
trips.trip_id, trips.trip_headsign, trips.direction_id 
from active_trips(date(now())) as trips 
inner join routes r using (route_id) order by r.route_type, route, trips.direction_id;


get routes for the day, and the number of trips per route

select r.route_type, coalesce(nullif(r.route_long_name, ''),
nullif(r.route_short_name, '')) route, 
trips.direction_id, count(*) as trips_count
from active_trips(date(now())) as trips inner join routes r using (route_id) 
group by r.route_type, route, trips.direction_id
order by r.route_type, route, trips.direction_id;


 route_type |                     route                     | direction_id | trips_count
------------+-----------------------------------------------+--------------+-------------
          0 | Green Line                                    |            0 |         578
          0 | Green Line                                    |            1 |         577
          0 | Mattapan High-Speed Line                      |            0 |         163
          0 | Mattapan High-Speed Line                      |            1 |         163
          1 | Blue Line                                     |            0 |         177
          1 | Blue Line                                     |            1 |         177
          1 | Orange Line                                   |            0 |         164
          1 | Orange Line                                   |            1 |         164
          1 | Red Line                                      |            0 |         214
          1 | Red Line                                      |            1 |         213
          2 | Fairmount Line                                |            0 |          14
          2 | Fairmount Line                                |            1 |          14
          2 | Fitchburg/South Acton Line                    |            0 |          17
          2 | Fitchburg/South Acton Line                    |            1 |          17

          2 | Providence/Stoughton Line                     |            0 |          36
          2 | Providence/Stoughton Line                     |            1 |          37
          3 | 1                                             |            0 |         116
          3 | 1                                             |            1 |         112

We can show this in the routes list

Next: the core part. Take one route name and direction, and return all
the trips for that route and direction.

CREATE FUNCTION route_trips_today(varchar, int) RETURNS SETOF trips AS $$
select trips.* 
from active_trips(date(now())) as trips 
inner join routes r using (route_id) 
where trips.direction_id = $2 and coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) = $1;
$$ LANGUAGE SQL;

mbta=# select * from route_trips_today('Red Line', 1);
mbta=# select * from route_trips_today('Providence/Stoughton Line', 1);
mbta=# select * from route_trips_today('1', 1);


 route_id |         service_id         | trip_id  |         trip_headsign         | direction_id | block_id | shape_id
----------+----------------------------+----------+-------------------------------+--------------+----------+----------
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438274 | Dudley Station via Mass. Ave. |            1 | C01-26   | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438276 | Dudley Station via Mass. Ave. |            1 | C01-26   | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438278 | Dudley Station via Mass. Ave. |            1 | C01-8    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438280 | Dudley Station via Mass. Ave. |            1 | C01-8    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438283 | Dudley Station via Mass. Ave. |            1 | C01-9    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438285 | Dudley Station via Mass. Ave. |            1 | C01-9    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438286 | Dudley Station via Mass. Ave. |            1 | C01-9    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438288 | Dudley Station via Mass. Ave. |            1 | C01-8    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438290 | Dudley Station via Mass. Ave. |            1 | C01-8    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438292 | Dudley Station via Mass. Ave. |            1 | C01-6    | 10016
 01-1084  | BUSS21-hbc21011-Weekday-02 | 14438293 | Dudley Station via Mass. Ave. |            1 | C01-2    | 10016


   route_id    | service_id |            trip_id            |       trip_headsign       | direction_id | block_id | shape_id
---------------+------------+-------------------------------+---------------------------+--------------+----------+----------
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-8802 | Providence (Train 8802)   |            1 |          |
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-8804 | Providence (Train 8804)   |            1 |          |
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-8806 | Providence (Train 8806)   |            1 |          |
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-800  | South Station (Train 800) |            1 |          |
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-802  | South Station (Train 802) |            1 |          |
 CR-Providence | CR-Weekday | CR-Providence-CR-Weekday-804  | South Station (Train 804) |            1 |          |

Now we make the schedule grid


mbta=# select * from stop_times where trip_id = 'CR-Providence-CR-Weekday-800';
           trip_id            | arrival_time | departure_time |     stop_id     | stop_sequence | stop_headsign | pickup_type | drop_off_type
------------------------------+--------------+----------------+-----------------+---------------+---------------+-------------+---------------
 CR-Providence-CR-Weekday-800 | 05:07:00     | 05:07:00       | Providence      |             1 |               |           0 |             1
 CR-Providence-CR-Weekday-800 | 05:17:00     | 05:17:00       | South Attleboro |             2 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 05:27:00     | 05:27:00       | Attleboro       |             3 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 05:36:00     | 05:36:00       | Mansfield       |             4 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 05:44:00     | 05:44:00       | Sharon          |             5 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 05:51:00     | 05:51:00       | Canton Junction |             8 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 05:56:00     | 05:56:00       | Route 128       |             9 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 06:01:00     | 06:01:00       | Hyde Park       |            10 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 06:11:00     | 06:11:00       | Ruggles         |            11 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 06:15:00     | 06:15:00       | Back Bay        |            12 |               |           0 |             0
 CR-Providence-CR-Weekday-800 | 06:20:00     | 06:20:00       | South Station   |            13 |               |           1 |             0
(11 rows)



This approach may need rethinking. To make the grid, we can do most of
that on the Ruby side: We can build a big table of all the stop_times
for a certain trip id set. Conceptually, this is easier.

CREATE FUNCTION stop_times_today(varchar, int) RETURNS SETOF stop_times AS $$
select * from stop_times st where trip_id in 
(select trip_id from route_trips_today($1, $2))
order by stop_id, arrival_time, stop_sequence;
$$ LANGUAGE SQL;

select stops.stop_name, stops.stop_code, st.* from stop_times_today('1', 1) st join stops using(stop_id);



------------------------------------------------------------------------
scrap


Version 1 method:

"select stoppings.stop_id, group_concat(stoppings.arrival_time, '|', stoppings.trip_id) as arrival_times from stoppings " +
      "where stoppings.trip_id in (#{trips.map(&:id).join(',')}) and stoppings.arrival_time > '#{now.time}' " +
      "group by stoppings.stop_id"

PostgreSQL



select stop_times.stop_id, array_agg(stop_times.arrival_time)
from stop_times
where trip_id in
('CR-Providence-CR-Weekday-800')
group by stop_times.stop_id ;


select stop_times.stop_id, 
array_agg(stop_times.arrival_time)
from stop_times
where trip_id in
(select trips.trip_id
from active_trips(date(now())) as trips 
inner join routes r using (route_id) 
where trips.direction_id = $2 and coalesce(nullif(r.route_long_name,
''), nullif(r.route_short_name, '')) = $1
)
group by stop_times.stop_id ;



SELECT id_field, array_agg(value_field1), array_agg(value_field2)
FROM data_table
GROUP BY id_field


  def all_next_arrivals_for_stops(trips, now)
    result = ActiveRecord::Base.connection.select_all("select stoppings.stop_id, group_concat(stoppings.arrival_time, '|', stoppings.trip_id) as arrival_times from stoppings " +
      "where stoppings.trip_id in (#{trips.map(&:id).join(',')}) and stoppings.arrival_time > '#{now.time}' " +
      "group by stoppings.stop_id")
    # each arrival time has this format:
    # 16:21:00|49739
    # the second number is the trip id

    data = result.inject({}) do |memo, hash|
      stop_id = hash["stop_id"].to_i
      arrival_times = hash["arrival_times"].
        split(',').
        map {|x| x.split('|')}.  # split into arrival time and trip id number
        select {|x| x[0] > now.time.to_s
      }.sort. # normally, we would limit the number here, but not now since we allow user to shift grid
        map {|x|
          @ordered_trip_ids << x[1] unless @ordered_trip_ids.include?(x[1])
          [format_time(x[0]),x[1].to_i] }
      if !arrival_times.empty?
        memo[stop_id] = @options[:limit] ? arrival_times[0,@options[:limit]] :  arrival_times
      end
      memo
    end
    #logger.debug "ALL NEXT ARRIVALS: #{data.inspect}"
    data
  end




  def all_next_arrivals_for_stops(trips, now)
    result = ActiveRecord::Base.connection.select_all("select stoppings.stop_id, group_concat(stoppings.arrival_time, '|', stoppings.trip_id) as arrival_times from stoppings " +
      "where stoppings.trip_id in (#{trips.map(&:id).join(',')}) and stoppings.arrival_time > '#{now.time}' " +
      "group by stoppings.stop_id")
    # each arrival time has this format:
    # 16:21:00|49739
    # the second number is the trip id

    data = result.inject({}) do |memo, hash|
      stop_id = hash["stop_id"].to_i
      arrival_times = hash["arrival_times"].
        split(',').
        map {|x| x.split('|')}.  # split into arrival time and trip id number
        select {|x| x[0] > now.time.to_s
      }.sort. # normally, we would limit the number here, but not now since we allow user to shift grid
        map {|x|
          @ordered_trip_ids << x[1] unless @ordered_trip_ids.include?(x[1])
          [format_time(x[0]),x[1].to_i] }
      if !arrival_times.empty?
        memo[stop_id] = @options[:limit] ? arrival_times[0,@options[:limit]] :  arrival_times
      end
      memo
    end
    #logger.debug "ALL NEXT ARRIVALS: #{data.inspect}"
    data
  end


