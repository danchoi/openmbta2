

select routes.route_id, max(routes.route_short_name) as route_short_name, count(route_id) from routes join trips using (route_id) group by routes.route_
id order by max(routes.route_short_name);



mbta=# select * from trips limit 10;
 route_id  |         service_id         | trip_id  | trip_headsign | direction_id | block_id | shape_id
-----------+----------------------------+----------+---------------+--------------+----------+----------
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942700 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942701 | Wonderland    |            1 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942702 | Wonderland    |            1 | B946_-18 |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942703 | Bowdoin       |            0 | B946_-7  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942704 | Wonderland    |            1 | B946_-7  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942705 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942706 | Bowdoin       |            0 | B946_-6  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942707 | Wonderland    |            1 | B946_-6  |
 948_-1079 | RTL111-hmb11011-Weekday-01 | 13942708 | Bowdoin       |            0 | B9462-3  |
 946_-1079 | RTL111-hmb11011-Weekday-01 | 13942709 | Wonderland    |            1 | B9462-3  |


mbta=# select * from stops limit 10;
   stop_id   | stop_code |     stop_name     | stop_desc |  stop_lat   |   stop_lon   | zone_id | stop_url | location_type | parent_station
-------------+-----------+-------------------+-----------+-------------+--------------+---------+----------+---------------+----------------
 place-alfcl |           | Alewife Station   |           |   42.395428 |   -71.142483 |         |          |             1 |
 place-andrw |           | Andrew Station    |           |   42.330154 |   -71.057655 |         |          |             1 |
 place-aport |           | Airport Station   |           |   42.374262 |   -71.030395 |         |          |             1 |
 place-aqucl |           | Aquarium Station  |           |   42.359784 |   -71.051652 |         |          |             1 |
 place-armnl |           | Arlington Station |           |   42.351902 |   -71.070893 |         |          |             1 |
 place-asmnl |           | Ashmont Station   |           |   42.284652 |   -71.064489 |         |          |             1 |
 place-bbsta |           | Back Bay Station  |           |    42.34735 |   -71.075727 |         |          |             1 |
 place-bmmnl |           | Beachmont Station |           | 42.39754234 | -70.99231944 |         |          |             1 |
 place-bomnl |           | Bowdoin Station   |           |   42.361365 |   -71.062037 |         |          |             1 |
 place-brdwy |           | Broadway Station  |           |   42.342622 |   -71.056967 |         |          |             1 |


mbta=# select * from stop_times limit 10;
 trip_id  | arrival_time | departure_time | stop_id | stop_sequence | stop_headsign | pickup_type | drop_off_type
----------+--------------+----------------+---------+---------------+---------------+-------------+---------------
 14021448 | 06:40:00     | 06:40:00       | 1       |             2 |               |           0 |             0
 14021524 | 06:15:00     | 06:15:00       | 1       |             2 |               |           0 |             0
 14045401 | 06:00:00     | 06:00:00       | 1       |             2 |               |           0 |             0
 14045403 | 07:05:00     | 07:05:00       | 1       |             2 |               |           0 |             0
 14045405 | 08:05:00     | 08:05:00       | 1       |             2 |               |           0 |             0
 14045407 | 09:05:00     | 09:05:00       | 1       |             2 |               |           0 |             0
 14045408 | 10:25:00     | 10:25:00       | 1       |             2 |               |           0 |             0
 14045409 | 19:00:00     | 19:00:00       | 1       |             2 |               |           0 |             0
 14045410 | 19:18:00     | 19:18:00       | 1       |             2 |               |           0 |             0
 14045411 | 20:30:00     | 20:30:00       | 1       |             2 |               |           0 |             0


Problem with arrival times in Postgres


mbta=# select max(arrival_time) from stop_times;
max
---------
9:52:00
(1 row)

May need to switch over to MySQL and use Postgres just for the
geographical part for now?

Try loading the CSV data into MySQL


Mysql load data infile 
https://bugs.launchpad.net/ubuntu/+source/mysql-dfsg-5.0/+bug/244406


sed 's/"""/"/g' stops.txt > stops.fixed.txt


The CSV import is messed up for MySQL.

Trying Postgresql furhter


grep  '"[[:digit:]]\{1\}:' stop_times.txt > bad.stoptimes.txt
sed 's/\<[[:digit:]]\{1\}:/0&/g'


------------------------------------------------------------------------
Thu May 26 10:58:53 EDT 2011

Reorganized the calendar table. Now we can do this sort of query:

mbta=# select * from calendar where service_days[(select 2)] = true;
mbta=# select * from calendar where service_days[(select 7)] = true;
mbta=# select * from calendar where service_days[(select 6)] = true;

Much happier with that.

select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true;


OK I now have a much more useful calendar table.


         service_id          |  service_days   | start_date |  end_date
-----------------------------+-----------------+------------+------------
 BUSN11-hbf11011-Weekday-02  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbg11011-Weekday-03  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbg11016-Saturday-03 | {f,f,f,f,f,t,f} | 2011-03-05 | 2011-03-12
 BUSN11-hbg11017-Sunday-03   | {f,f,f,f,f,f,t} | 2011-03-06 | 2011-03-13
 BUSN11-hbl11011-Weekday-02  | {t,t,t,t,t,f,f} | 2011-02-28 | 2011-03-18
 BUSN11-hbl11016-Saturday-02 | {f,f,f,f,f,t,f} | 2011-03-05 | 2011-03-12
 BUSN11-hbl11017-Sunday-02   | {f,f,f,f,f,f,t} | 2011-03-06 | 2011-03-13


select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();

This works great

select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();
         service_id         |  service_days   | start_date |  end_date
----------------------------+-----------------+------------+------------
 BUSN21-hbf21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbg21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbl21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSN21-hbt21021-Weekday-02 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 BUSN21-htt21021-Weekday-02 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 BUSS21-hba21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbb21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbc21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbq21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 BUSS21-hbs21011-Weekday-02 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 LRV211-hlb21021-Weekday-01 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 LRV211-hlm21021-Weekday-01 | {t,t,t,t,t,f,f} | 2011-05-02 | 2011-06-24
 RTL211-hmb21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 RTL211-hmo21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 RTL211-hms21011-Weekday-01 | {t,t,t,t,t,f,f} | 2011-03-21 | 2011-06-24
 CR-Weekday                 | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
 Boat-FallWeekday           | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
 Logan-Weekday              | {t,t,t,t,t,f,f} | 2011-03-19 | 2011-06-24
(18 rows)


create view current_services as select * from calendar where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now();

fix calendar_date table to use date type


select service_id, service_type from (
  select service_id, 'normal' as service_type from calendar 
  where service_days[(select to_char(now(), 'ID'))::int - 1] = true and start_date <= now() and end_date >= now() 
  UNION
  select service_id, 'added' as service_type from calendar_dates 
  where exception_type = 'add' and date = now()
) services
EXCEPT 
  select service_id, 'removed' as service_type from calendar_dates 
  where exception_type = 'removed' and date = now();


CREATE FUNCTION active_services(date) RETURNS setof varchar AS $$
select service_id from (
  select service_id from calendar 
  where service_days[(select to_char($1, 'ID'))::int] = true and start_date <= $1 and end_date >= $1
  UNION
  select service_id from calendar_dates 
  where exception_type = 'add' and date = $1
) services
EXCEPT 
  select service_id from calendar_dates 
  where exception_type = 'remove' and date = $1;
$$ language sql;

select active_services(date('20110511'));
select active_services(date('20110530')) as service_id order by service_id;

------------------------------------------------------------------------

This is more explicit:


CREATE FUNCTION active_services2(date) RETURNS setof record AS $$
  select service_id, 'normal' as service_type from calendar 
  where service_days[(select to_char($1, 'ID'))::int] = true and start_date <= $1 and end_date >= $1
UNION
  select service_id, 'added' as service_type from calendar_dates 
  where exception_type = 'add' and date = $1
UNION 
  select service_id, 'remove' as service_type from calendar_dates 
  where exception_type = 'remove' and date = $1;
$$ language sql;


          active_services2
-------------------------------------
 (BUSN21-hbt21021-Weekday-02,normal)
 (RTL211-hmb21me7-Sunday-01,added)
 (Logan-Weekday,normal)
 (BUSN21-htt21021-Weekday-02,normal)
 (BUSS21-hba21011-Weekday-02,normal)
 (BUSN21-hbg21011-Weekday-02,normal)
 (LRV211-hlm21021-Weekday-01,remove)
 (BUSS21-hbc21011-Weekday-02,normal)
 (RTL211-hms21me7-Sunday-01,added)
 (BUSN21-hbl21011-Weekday-02,remove)
 (LRV211-hlb21021-Weekday-01,normal)
 (Boat-FallWeekday,normal)


select active_services2(date('20110530'));

select * from active_services2(date('20110530')) f(service_id text, service_type text);

Got it:

These two should be equivalent:

select active_services(date('20110530')) as service_id order by service_id;

select service_id, count(service_id) from active_services2(date('20110530')) f(service_id text, service_type text) group by service_id having count(service_id) < 2 order by service_id;

Use the first version, the second to check.


mbta=# select count(*) from trips where service_id in (select service_id current_services);
count
--------
121866
(1 row)

select count(*) from trips where service_id in ( select active_services(date('20110530')) as service_id order by service_id);



Now create a function that produces the trips records for a certain date.

CREATE FUNCTION active_trips(date) RETURNS SETOF trips AS $$
select * from trips where service_id in (select active_services($1) as service_id);
$$ LANGUAGE SQL;

------------------------------------------------------------------------
# FIND TRIPS REMAINING

# We should denormalize! This is too slow.

select trip_id, max(stop_times.arrival_time) from trips 
inner join stop_times using(trip_id)
where service_id in (select active_services(date(now())) as service_id)
group by trips.trip_id
having max(stop_times.arrival_time) > '12:00:00'
;
------------------------------------------------------------------------


This works:

select * from active_trips(date(now()));

Next we need a function that shows the active trips for a mode of transport


use nullif and coalesce:

select r.route_type, r.route_id, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, 
trips.trip_id, trips.trip_headsign, trips.direction_id 
from active_trips(date(now())) as trips 
inner join routes r using (route_id) order by r.route_type, route, trips.direction_id;


get routes for the day, and the number of trips per route

GET ROUTES

select r.route_type, coalesce(nullif(r.route_long_name, ''),
nullif(r.route_short_name, '')) route, 
trips.direction_id, count(*) as trips_count
from active_trips(date(now())) as trips inner join routes r using (route_id) 
group by r.route_type, route, trips.direction_id
order by r.route_type, route, trips.direction_id;


 route_type |                     route                     | direction_id | trips_count
------------+-----------------------------------------------+--------------+-------------
          0 | Green Line                                    |            0 |         578
          0 | Green Line                                    |            1 |         577
          0 | Mattapan High-Speed Line                      |            0 |         163
          2 | Providence/Stoughton Line                     |            0 |          36
          2 | Providence/Stoughton Line                     |            1 |          37


GET ROUTES II

query for remaining trips

select r.route_type, coalesce(nullif(r.route_long_name, ''),
nullif(r.route_short_name, '')) route, 
trips.direction_id, count(*) as trips_left
from active_trips(date(   now()  )) as trips inner join routes r using (route_id) 
where trips.finished_at >   '20:00:00' 
group by r.route_type, route, trips.direction_id 
order by r.route_type, route, trips.direction_id;


GET ROUTES II b

select a.route_type, a.route, a.direction_id, b.trips_left from 
(select r.route_type, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, trips.direction_id
from active_trips(date(   now()  )) as trips inner join routes r using (route_id)
group by r.route_type, route, trips.direction_id) a
left outer join
(select r.route_type, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, 
trips.direction_id,
count(*) as trips_left
from active_trips(date(   now()  )) as trips inner join routes r using (route_id) 
where trips.finished_at >   '20:00:00' 
group by r.route_type, route, trips.direction_id) b
on (a.route_type = b.route_type and a.route = b.route and a.direction_id = b.direction_id)
order by route_type, route, direction_id;


GET ROUTES III

DROP FUNCTION available_routes(timestamp with time zone);
CREATE FUNCTION available_routes(timestamp with time zone) RETURNS setof record AS $$
select a.route_type, a.route, a.direction_id, 
coalesce(b.trips_left, 0), b.headsign from 
(select r.route_type, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, trips.direction_id
from active_trips(adjusted_date($1)) as trips inner join routes r using (route_id)
group by r.route_type, route, trips.direction_id) a
left outer join
  (select r.route_type, coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) route, 
  trips.direction_id,
  count(*) as trips_left,
  max(trip_headsign) as headsign
  from active_trips(adjusted_date($1)) as trips inner join routes r using (route_id) 
  where trips.finished_at > adjusted_time($1)
  group by r.route_type, route, trips.direction_id) b
  on (a.route_type = b.route_type and a.route = b.route and a.direction_id = b.direction_id)
  order by route_type, route, direction_id;
$$ language sql;


select available_routes(now());


FOR ROUTES USE THIS CALL:

select * from available_routes(now()) as (route_type smallint, route varchar, direction_id smallint, trips_left bigint);

 route_type |                    route                    | direction_id | trips_left
------------+---------------------------------------------+--------------+------------
          0 | Green Line                                  |            0 |        121
          0 | Green Line                                  |            1 |        102


Make this into a database function?


\df+ available_routes


to_char(timestamp, "HH24:MI:SS")
p.191 postgres pdf

------------------------------------------------------------------------
TRIPS FOR A ROUTE

We can show this in the routes list

Next: the core part. Take one route name and direction, and return all
the trips for that route and direction.


Two functions:
- route_trips_today
- stop_times_today (calls the former)


CREATE FUNCTION route_trips_today(varchar, int) RETURNS SETOF trips AS $$
select trips.* 
from active_trips(date(now())) as trips 
inner join routes r using (route_id) 
where trips.direction_id = $2 and coalesce(nullif(r.route_long_name, ''), nullif(r.route_short_name, '')) = $1;
$$ LANGUAGE SQL;

mbta=# select * from route_trips_today('Red Line', 1);
mbta=# select * from route_trips_today('Providence/Stoughton Line', 1);
mbta=# select * from route_trips_today('1', 1);
mbta=# select * from stop_times where trip_id = 'CR-Providence-CR-Weekday-800';

This approach may need rethinking. To make the grid, we can do most of
that on the Ruby side: We can build a big table of all the stop_times
for a certain trip id set. Conceptually, this is easier.


HENCE:

CREATE FUNCTION stop_times_today(varchar, int) RETURNS SETOF stop_times AS $$
select * from stop_times st where trip_id in 
(select trip_id from route_trips_today($1, $2))
order by stop_id, arrival_time, stop_sequence;
$$ LANGUAGE SQL;

This should produce the raw data from which to generate the table grid
for a day:

CALL FOR TRIPS FOR A ROUTE:

- first argument is route name, then direction

select stops.stop_name, stops.stop_code, st.* from stop_times_today('1', 1) st join stops using(stop_id);

- more complete example:

select stops.stop_name, stops.stop_lat, stops.stop_lon, stops.parent_station, stops.stop_code, st.* from stop_times_today('1', 1) st join stops using(stop_id);

This will return 4032 rows for Bus, fewer for other routes;

Example record:
-[ RECORD 1 ]--+------------------------------------------------
stop_name      | Albany St @ Northampton St
stop_lat       | 42.33279
stop_lon       | -71.074516
parent_station |
stop_code      | 10099
trip_id        | 14442911
arrival_time   | 05:30:00
departure_time | 05:30:00
stop_id        | 10099
stop_sequence  | 30
stop_headsign  |
pickup_type    | 0
drop_off_type  | 0


------------------------------------------------------------------------

Need to fix available trip calculation for times from 12 am to 3am

The date also needs to be the PREVIOUS date if the time is after midnight.

The simple way is to parameterize available_routes(date, text) # where text is
the time string e.g., "24:05:00" for 5 minutes past midnight.


CREATE FUNCTION adjusted_date(x timestamp with time zone) RETURNS date AS $$
BEGIN
  IF extract(hour from x) < 4 THEN 
    RETURN date( x - interval '24 hours' );    
  ELSE 
    RETURN date(x);
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION adjusted_time(x timestamp with time zone) RETURNS character(8) AS $$
DECLARE
  h integer;
  m integer;
  s  integer;
BEGIN
  h := extract(hour from x);
  m := extract(minutes from x);
  IF h  < 4 THEN 
    h := h + 24;
  END IF;
  RETURN lpad(h::text, 2, '0') || ':' || m || ':00';
END;
$$ LANGUAGE plpgsql;




mbta=# select extract(hour from now());
 date_part
-----------
         0
(1 row)

mbta=# select extract(minutes from now());
 date_part
-----------
        33


mbta=# select extract(hour from now()) || ':' || extract(minutes from now()) || ':00';
 ?column?
----------
 0:36:00
(1 row)


May need to assign variables before function.



------------------------------------------------------------------------
Tue May 31 11:50:36 EDT 2011


The v3 client assumes stop_id is an integer because it calls stringValue on it.

Need to assign integer IDs to all the stops with string ids?

ALTER table stops add column stop_integer_id serial;


------------------------------------------------------------------------

REALTIME

route config has <direction tag="1_01203213_0" title="Harvard Station via Mass Ave." etc.

This looks like all that is necessary

_0 means outbound

The predictions file has 
<predictions routeTitle="1" routeTag="1" stopTitle="Dudley station" stopTag="64">
  <direction title="[headsign]">
   <prediction -> has a dirTag="1_100117v0_0" 

  I think I can infer everything from the prediction thing


Use this query to match nextbus routeTags with routes from GTFS

select route_id, route_short_name, tag nextbus_tag from routes left outer join nextbus_routes on (trim(leading '0' from  split_part(routes.route_id, '-', 1)) = nextbus_routes.
tag) where routes.route_type = 3;

